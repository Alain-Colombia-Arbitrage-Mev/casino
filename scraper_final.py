#!/usr/bin/env python3
"""
Scraper Final de Lightning Roulette - COMPLETAMENTE FUNCIONAL
Con Redis y PostgreSQL sincronizados y sin login repetido
"""

import time
import json
import os
from datetime import datetime
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager
from dotenv import load_dotenv

# Importar la clase de sincronizaci√≥n
from database_sync import SyncedRouletteDatabase, log_message

# Cargar variables de entorno
load_dotenv()

def clean_local_files():
    """Limpiar archivos locales de datos"""
    log_message("üóÇÔ∏è Limpiando archivos locales...")

    files_to_clean = [
        "roulette_data/history_counter.txt",
        "roulette_data/last_seen_numbers.json",
        "roulette_data/pending_numbers.txt",
        "roulette_data/processed_numbers.txt",
        "roulette_data/roulette_numbers.json"
    ]

    cleaned_count = 0

    for file_path in files_to_clean:
        try:
            if os.path.exists(file_path):
                os.remove(file_path)
                log_message(f"üóëÔ∏è Eliminado: {file_path}")
                cleaned_count += 1
            else:
                log_message(f"‚ÑπÔ∏è No existe: {file_path}")
        except Exception as e:
            log_message(f"‚ùå Error eliminando {file_path}: {e}", "ERROR")

    # Crear archivos b√°sicos limpios
    try:
        os.makedirs("roulette_data", exist_ok=True)

        # Crear archivos con contenido inicial
        with open("roulette_data/history_counter.txt", "w") as f:
            f.write("0")

        with open("roulette_data/last_seen_numbers.json", "w") as f:
            f.write("[]")

        with open("roulette_data/processed_numbers.txt", "w") as f:
            f.write("")

        with open("roulette_data/pending_numbers.txt", "w") as f:
            f.write("")

        with open("roulette_data/roulette_numbers.json", "w") as f:
            f.write("[]")

        log_message("‚úÖ Archivos locales reiniciados correctamente")
        return True

    except Exception as e:
        log_message(f"‚ùå Error reiniciando archivos: {e}", "ERROR")
        return False

def purge_all_databases_auto():
    """Funci√≥n para limpiar completamente todas las bases de datos autom√°ticamente"""

    log_message("=" * 60)
    log_message("üßπ DEPURACI√ìN AUTOM√ÅTICA ANTES DE INICIAR SCRAPER")
    log_message("=" * 60)

    print("\nüßπ Depurando todas las bases de datos autom√°ticamente...")
    print("   ‚Ä¢ Redis - Todas las claves de roulette")
    print("   ‚Ä¢ PostgreSQL - Tabla roulette_numbers completa")
    print("   ‚Ä¢ Archivos locales - Historial y contadores")

    log_message("üöÄ Iniciando depuraci√≥n autom√°tica...")

    # Inicializar base de datos
    db = SyncedRouletteDatabase()

    # Limpiar bases de datos
    redis_success, postgres_success = db.purge_all_data()

    # Limpiar archivos locales
    local_files_cleaned = clean_local_files()

    # Resultado final
    if redis_success and postgres_success and local_files_cleaned:
        log_message("üéâ ¬°DEPURACI√ìN AUTOM√ÅTICA EXITOSA!")
        log_message("‚úÖ Redis: Limpio")
        log_message("‚úÖ PostgreSQL: Limpio")
        log_message("‚úÖ Archivos locales: Limpios")
        print("\nüöÄ Sistema completamente limpio - Iniciando scraper...")
    else:
        log_message("‚ö†Ô∏è Depuraci√≥n parcial:")
        log_message(f"   Redis: {'‚úÖ' if redis_success else '‚ùå'}")
        log_message(f"   PostgreSQL: {'‚úÖ' if postgres_success else '‚ùå'}")
        log_message(f"   Archivos locales: {'‚úÖ' if local_files_cleaned else '‚ùå'}")
        print("\n‚ö†Ô∏è Algunas bases no se pudieron limpiar completamente")

    db.close_connections()
    log_message("=" * 60)
    return redis_success and postgres_success and local_files_cleaned

# Configuraci√≥n
LOGIN_URL = os.getenv("LOGIN_URL", "https://www.iamonstro.com.br/sistema/index.php")
DASHBOARD_URL = os.getenv("DASHBOARD_URL", "https://www.iamonstro.com.br/sistema/dashboard.php?mesa=Lightning%20Roulette")
USERNAME = os.getenv("ROULETTE_USERNAME", "tu_usuario")
PASSWORD = os.getenv("ROULETTE_PASSWORD", "tu_password")
REFRESH_INTERVAL = int(os.getenv("REFRESH_INTERVAL", "10"))

class FinalRouletteScraper:
    """Scraper final con todas las correcciones aplicadas"""

    def __init__(self):
        self.driver = None
        self.db_handler = SyncedRouletteDatabase()
        self.last_number = None
        self.consecutive_errors = 0

    def setup_chrome_driver(self):
        """Configurar Chrome driver optimizado"""
        options = Options()
        options.add_argument("--headless")
        options.add_argument("--disable-gpu")
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        options.add_argument("--disable-blink-features=AutomationControlled")
        options.add_experimental_option("excludeSwitches", ["enable-automation"])
        options.add_experimental_option('useAutomationExtension', False)
        options.add_argument("--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36")

        driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)
        driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")

        return driver

    def save_numbers_to_json(self, numbers):
        """Guardar n√∫meros en archivo JSON local"""
        # Validate numbers are between 0-36
        valid_numbers = []
        for num in numbers:
            try:
                num_int = int(num)
                if 0 <= num_int <= 36:
                    valid_numbers.append(num_int)
                else:
                    log_message(f"‚ö†Ô∏è N√∫mero inv√°lido ignorado en JSON: {num} (debe ser 0-36)", "WARN")
            except (ValueError, TypeError):
                log_message(f"‚ö†Ô∏è N√∫mero no num√©rico ignorado en JSON: {num}", "WARN")

        data = {
            "timestamp": datetime.now().isoformat(),
            "numbers": valid_numbers
        }

        data_dir = "roulette_data"
        if not os.path.exists(data_dir):
            os.makedirs(data_dir)

        json_file = os.path.join(data_dir, "roulette_numbers.json")
        with open(json_file, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2)

    def setup_session(self):
        """Configurar sesi√≥n persistente con login una sola vez"""
        log_message("üîß Configurando sesi√≥n persistente...")

        try:
            self.driver = self.setup_chrome_driver()

            # Login
            self.driver.get(LOGIN_URL)
            time.sleep(2)

            wait = WebDriverWait(self.driver, 10)
            email_field = wait.until(EC.presence_of_element_located((By.NAME, "email")))
            email_field.clear()
            email_field.send_keys(USERNAME)

            password_field = self.driver.find_element(By.NAME, "senha")
            password_field.clear()
            password_field.send_keys(PASSWORD)
            password_field.send_keys(Keys.RETURN)

            time.sleep(3)

            # Navigate to dashboard
            self.driver.get(DASHBOARD_URL)
            time.sleep(2)

            log_message("‚úÖ Sesi√≥n persistente configurada")
            return True

        except Exception as e:
            log_message(f"‚ùå Error configurando sesi√≥n: {e}", "ERROR")
            if self.driver:
                self.driver.quit()
                self.driver = None
            return False

    def extract_numbers_fast(self):
        """Extraer n√∫meros r√°pidamente sin login"""
        if not self.driver:
            return []

        try:
            self.driver.refresh()
            time.sleep(1.5)

            numbers = self.driver.execute_script("""
            var table = document.querySelector("table");
            if (!table) return [];

            var rows = table.querySelectorAll("tr");
            var numbers = [];

            // Leer desde ABAJO hacia ARRIBA (m√°s reciente al m√°s antiguo)
            for (var i = rows.length - 1; i >= 0; i--) {
                var cells = rows[i].querySelectorAll("td");
                if (cells.length > 0) {
                    var text = cells[0].textContent.trim();
                    if (text && !isNaN(text)) {
                        var num = parseInt(text);
                        // Validar que el n√∫mero est√© en rango 0-36
                        if (num >= 0 && num <= 36) {
                            numbers.push(num);
                        }
                    }
                }
            }

            // NO reverse - ya est√°n en orden correcto (m√°s reciente primero)
            return numbers;
            """)

            if numbers and len(numbers) > 0:
                log_message(f"‚ö° Extra√≠dos {len(numbers)} n√∫meros v√°lidos (0-36). M√°s reciente: {numbers[0]}")
                return numbers
            else:
                log_message("‚ö†Ô∏è No se encontraron n√∫meros v√°lidos")
                return []

        except Exception as e:
            log_message(f"‚ùå Error extrayendo n√∫meros: {e}", "ERROR")
            return []

    def run(self):
        """Ejecutar el scraper principal"""
        log_message("üöÄ SCRAPER FINAL - REDIS + POSTGRESQL SINCRONIZADOS")
        log_message("‚ú® Caracter√≠sticas: Sin login repetido, bases sincronizadas, ultra r√°pido, n√∫meros 0-36")

        try:
            # üßπ DEPURACI√ìN AUTOM√ÅTICA ANTES DE INICIAR
            log_message("üßπ Ejecutando depuraci√≥n autom√°tica antes de iniciar...")
            purge_success = purge_all_databases_auto()

            if not purge_success:
                log_message("‚ö†Ô∏è Advertencia: La depuraci√≥n no fue completamente exitosa")
                log_message("üîÑ Continuando con el scraper de todos modos...")

            # Reinicializar conexi√≥n de base de datos despu√©s de la limpieza
            if self.db_handler:
                self.db_handler.close_connections()
            self.db_handler = SyncedRouletteDatabase()

            # Mostrar estado inicial (despu√©s de limpieza)
            log_message("üìä Estado despu√©s de la depuraci√≥n:")
            self.db_handler.get_sync_status()

            # Configurar sesi√≥n inicial
            if not self.setup_session():
                log_message("‚ùå No se pudo configurar la sesi√≥n")
                return

            # Main loop
            while True:
                try:
                    log_message("‚ö° Extracci√≥n r√°pida...")

                    numbers = self.extract_numbers_fast()

                    if not numbers:
                        self.consecutive_errors += 1
                        log_message(f"‚ùå Sin n√∫meros. Errores: {self.consecutive_errors}")

                        if self.consecutive_errors >= 3:
                            log_message("üîÑ Reconfiguraci√≥n de sesi√≥n...")
                            if self.driver:
                                self.driver.quit()
                            if self.setup_session():
                                self.consecutive_errors = 0
                            else:
                                time.sleep(30)
                        else:
                            time.sleep(REFRESH_INTERVAL)
                        continue

                    self.consecutive_errors = 0

                    # Guardar en JSON local
                    self.save_numbers_to_json(numbers)

                    # Verificar cambios
                    current_number = numbers[0]
                    log_message(f"üî¢ N√∫mero actual: {current_number} (v√°lido 0-36)")

                    if current_number == self.last_number:
                        log_message(f"‚è∏Ô∏è Sin cambios ({current_number}). Esperando...")
                        time.sleep(REFRESH_INTERVAL)
                        continue

                    # ¬°CAMBIO DETECTADO!
                    log_message(f"üÜï ¬°NUEVO N√öMERO! {self.last_number} ‚Üí {current_number}")

                    # SOLO guardar EL n√∫mero m√°s reciente (uno por vez)
                    numbers_to_save = [current_number]
                    log_message(f"üéØ Guardando SOLO el m√°s reciente: {current_number}")

                    # GUARDAR EN AMBAS BASES DE DATOS
                    redis_success, postgres_success = self.db_handler.save_numbers(numbers_to_save)

                    # Actualizar √∫ltimo n√∫mero
                    self.last_number = current_number

                    # Mostrar estado de sincronizaci√≥n
                    self.db_handler.get_sync_status()

                    # Pausa
                    log_message(f"‚è∞ Pausa de {REFRESH_INTERVAL}s...")
                    time.sleep(REFRESH_INTERVAL)

                except KeyboardInterrupt:
                    log_message("üõë Detenido por usuario")
                    break
                except Exception as e:
                    self.consecutive_errors += 1
                    log_message(f"‚ùå Error: {e}")
                    time.sleep(10)

        finally:
            if self.driver:
                self.driver.quit()
            self.db_handler.close_connections()
            log_message("üîå Scraper cerrado")

def main():
    """Funci√≥n principal"""
    scraper = FinalRouletteScraper()
    scraper.run()

if __name__ == "__main__":
    main()
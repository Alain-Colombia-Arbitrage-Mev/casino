import { createClient } from '@supabase/supabase-js';
// Importaci√≥n para Nuxt 3
import { useRuntimeConfig } from '#app';

// Cach√© en memoria para reducir consultas
let cachedNumbers: any[] = [];
let lastFetchTimestamp = 0;
const CACHE_LIFETIME = 10000; // 10 segundos de vida para la cach√©

// Configurar cliente de Supabase
const useSupabase = () => {
  // Para Nuxt 3 necesitamos importar useRuntimeConfig
  const { public: config } = useRuntimeConfig();
  const supabaseUrl = config.supabaseUrl;
  const supabaseKey = config.supabaseKey;
  
  return createClient(supabaseUrl, supabaseKey);
};

// Obtener los √∫ltimos n√∫meros de la ruleta
export const getLastRouletteNumbers = async (limit = 20) => {
  // Verificar si podemos usar la cach√©
  const now = Date.now();
  if (cachedNumbers.length > 0 && (now - lastFetchTimestamp) < CACHE_LIFETIME) {
    return cachedNumbers.slice(0, limit);
  }
  
  const supabase = useSupabase();

  try {
    // Buscar los √∫ltimos n√∫meros ordenados por fecha de creaci√≥n (descendente)
    // Esto garantiza que el n√∫mero m√°s reciente siempre sea el primero en el resultado
    const { data, error } = await supabase
      .from('roulette_numbers_individual')
      .select('id, history_entry_id, number_value, color, created_at')
      .order('created_at', { ascending: false })
      .limit(Math.min(limit, 100)) // Limitar a m√°ximo 100 para mejor rendimiento
      .range(0, Math.min(limit, 100) - 1);  // Asegurar que obtenemos exactamente los l√≠mites solicitados
    
    if (error) {
      console.error('Error fetching roulette numbers:', error);
      return cachedNumbers.length ? cachedNumbers.slice(0, limit) : [];
    }
    
    // Transformar los datos para mantener compatibilidad con el resto del c√≥digo
    // Los datos ya vienen ordenados con el √∫ltimo jugado primero porque ordenamos por created_at desc
    const transformedData = data.map(item => ({
      id: item.id,
      history_entry_id: item.history_entry_id,
      number: item.number_value, // Mapear number_value a number para compatibilidad
      color: item.color,
      created_at: item.created_at,
      timestamp: item.created_at // Para compatibilidad con c√≥digo existente
    }));
    
    // Actualizar la cach√©
    cachedNumbers = transformedData;
    lastFetchTimestamp = now;
    
    return transformedData;
  } catch (e) {
    console.error('Error inesperado al obtener n√∫meros:', e);
    return cachedNumbers.length ? cachedNumbers.slice(0, limit) : [];
  }
};

// Insertar un nuevo n√∫mero de ruleta
export const insertRouletteNumber = async (number: number, customTimestamp?: string) => {
  const supabase = useSupabase();
  
  // Validar que el n√∫mero sea v√°lido en la ruleta (0-36)
  if (number < 0 || number > 36 || isNaN(number)) {
    console.error(`N√∫mero inv√°lido: ${number}. Debe estar entre 0 y 36.`);
    return null;
  }
  
  // Determinar el color del n√∫mero
  let color = 'black';
  const redNumbers = [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36];
  
  if (number === 0) {
    color = 'green';
  } else if (redNumbers.includes(number)) {
    color = 'red';
  }
  
  // Intentar insertar hasta 3 veces como m√°ximo en caso de error
  let attempts = 0;
  const maxAttempts = 3;
  let data = null;
  let lastError = null;
  
  while (attempts < maxAttempts && !data) {
    attempts++;
    try {
      // Primero, crear una entrada en la tabla roulette_history
      const historyResult = await supabase
        .from('roulette_history')
        .insert({
          numbers_string: number.toString()
        })
        .select();
      
      if (historyResult.error) {
        console.error('Error al insertar en roulette_history:', historyResult.error);
        throw historyResult.error;
      }
      
      if (!historyResult.data || historyResult.data.length === 0) {
        console.error('No se recibieron datos al insertar en roulette_history');
        throw new Error('No se pudo crear la entrada en roulette_history');
      }
      
      const historyEntryId = historyResult.data[0].id;
      console.log(`Entrada creada en roulette_history con ID: ${historyEntryId}`);
      
      // Ahora insertar en roulette_numbers_individual con la referencia a history
      const timestamp = customTimestamp || new Date().toISOString();
      const result = await supabase
        .from('roulette_numbers_individual')
        .insert({
          history_entry_id: historyEntryId,
          number_value: number,
          color,
          created_at: timestamp
        })
        .select();
      
      if (result.error) {
        console.error('Error al insertar en roulette_numbers_individual:', result.error);
        throw result.error;
      }
      
      if (!result.data || result.data.length === 0) {
        console.error('No se recibieron datos al insertar en roulette_numbers_individual');
        throw new Error('No se pudo crear la entrada en roulette_numbers_individual');
      }
      
      console.log(`N√∫mero ${number} insertado correctamente`);
      
      // Transformar los datos para mantener compatibilidad con el resto del c√≥digo
      data = result.data.map(item => ({
        ...item,
        number: item.number_value // Agregar campo number para compatibilidad
      }));
      
      // Invalidar la cach√© para asegurar que los nuevos datos se carguen
      cachedNumbers = [];
      lastFetchTimestamp = 0;
      
    } catch (error: any) {
      lastError = error;
      console.error(`Error en intento ${attempts} al insertar n√∫mero ${number}:`, error);
      
      // Si es un error de permisos o de conexi√≥n, no tiene sentido reintentar
      if (error.code === 'PGRST301' || error.message?.includes('permission') || 
          error.message?.includes('network') || error.message?.includes('connection')) {
        console.error('Error de permisos o conexi√≥n, no se reintentar√°');
        break;
      }
      
      // Esperar un breve tiempo antes de reintentar
      if (attempts < maxAttempts) {
        const delay = 300 * attempts; // Aumentar el tiempo de espera en cada intento
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  if (!data || !data[0]) {
    // Si despu√©s de todos los intentos no hay datos, intentar una inserci√≥n de emergencia solo en history
    try {
      console.error(`Realizando inserci√≥n de emergencia para n√∫mero ${number}`);
      
      const emergencyResult = await supabase
        .from('roulette_history')
        .insert({
          numbers_string: `${number} (emergencia)`,
          notes: 'Inserci√≥n directa tras fallo en flujo normal'
        })
        .select();
      
      if (emergencyResult.data && emergencyResult.data.length > 0) {
        console.log('Inserci√≥n de emergencia exitosa');
        return {
          id: emergencyResult.data[0].id,
          number_value: number,
          number: number,
          color: color,
          created_at: new Date().toISOString()
        };
      }
    } catch (emergencyError) {
      console.error('Error en inserci√≥n de emergencia:', emergencyError);
    }
    
    console.error(`Error persistente al insertar n√∫mero ${number}:`, lastError);
    return null;
  }
  
  return data[0];
};

// Funci√≥n para verificar duplicados consecutivos de forma inteligente
const checkConsecutiveDuplicate = (number: number, recentNumbers: number[]) => {
  // VALIDACI√ìN REFORZADA para evitar duplicados accidentales
  if (recentNumbers.length === 0) {
    return { isDuplicate: false, message: '' };
  }
  
  // VALIDACI√ìN 1: Duplicado inmediato (√∫ltimo n√∫mero igual)
  if (recentNumbers[0] === number) {
    return {
      isDuplicate: true,
      message: `El n√∫mero ${number} se repite inmediatamente despu√©s del √∫ltimo n√∫mero. ¬øEst√° seguro de que es correcto? Esto es inusual en ruleta.`
    };
  }
  
  // VALIDACI√ìN 2: N√∫mero aparece en los √∫ltimos 3 n√∫meros
  if (recentNumbers.length >= 2) {
    const lastThree = recentNumbers.slice(0, 3);
    if (lastThree.includes(number)) {
      const position = lastThree.indexOf(number) + 1;
      return {
        isDuplicate: true,
        message: `El n√∫mero ${number} ya apareci√≥ recientemente en los √∫ltimos n√∫meros (posici√≥n: ${position}). ¬øEst√° seguro?`
      };
    }
  }
  
  // VALIDACI√ìN 3: Detectar patrones sospechosos (mismo n√∫mero aparece frecuentemente)
  if (recentNumbers.length >= 4) {
    const lastFive = recentNumbers.slice(0, 5);
    const countInRecent = lastFive.filter(n => n === number).length;
    if (countInRecent >= 2) {
      return {
        isDuplicate: true,
        message: `El n√∫mero ${number} ya apareci√≥ ${countInRecent} veces en los √∫ltimos ${lastFive.length} n√∫meros. Esto es estad√≠sticamente inusual.`
      };
    }
  }
  
  return { isDuplicate: false, message: '' };
};

// Funci√≥n para procesar una entrada de texto con n√∫meros separados por comas
export const processNumbersInput = async (numbersText: string) => {
  // Comprobar si la entrada es v√°lida
  if (!numbersText || numbersText.trim() === '') {
    console.error('Entrada vac√≠a');
    return null;
  }
  
  console.log(`Procesando entrada: "${numbersText}"`);
  
  // NUEVO: Obtener los √∫ltimos n√∫meros para validar duplicados consecutivos
  const recentNumbers = await getLastRouletteNumbers(5); // Reducir a 5 n√∫meros m√°s recientes
  const recentNumberValues = recentNumbers.map(item => item.number);
  
  // Manejo especial para entrada de voz (solo un n√∫mero)
  if (/^\d+$/.test(numbersText.trim())) {
    const singleNumber = parseInt(numbersText.trim());
    
    // Validar el n√∫mero para ruleta
    if (singleNumber < 0 || singleNumber > 36 || isNaN(singleNumber)) {
      console.error(`N√∫mero inv√°lido: ${singleNumber}. Debe estar entre 0 y 36.`);
      return null;
    }
    
    // MEJORADO: Verificar duplicados consecutivos m√°s inteligentemente
    const isDuplicateConsecutive = checkConsecutiveDuplicate(singleNumber, recentNumberValues);
    if (isDuplicateConsecutive.isDuplicate) {
      console.error(`El n√∫mero ${singleNumber} se detect√≥ como duplicado consecutivo.`);
      return {
        error: true,
        message: isDuplicateConsecutive.message,
        isDuplicate: true,
        duplicateNumber: singleNumber,
        allowOverride: true // Permitir anular la validaci√≥n si es necesario
      };
    }
    
    console.log(`Procesando n√∫mero √∫nico del reconocimiento de voz: ${singleNumber}`);
    
    // Insertar el n√∫mero directamente
    try {
      const result = await insertRouletteNumber(singleNumber);
      
      if (!result) {
        console.error(`No se pudo insertar el n√∫mero ${singleNumber}`);
        return null;
      }
      
      // Invalidar la cach√© forzosamente
      cachedNumbers = [];
      lastFetchTimestamp = 0;
      
      console.log(`N√∫mero ${singleNumber} procesado correctamente`);
      
      return {
        processedCount: 1,
        totalInput: 1,
        numbers: [singleNumber],
        lastPlayed: singleNumber,
        individualEntries: [result],
      };
    } catch (error) {
      console.error(`Error al procesar n√∫mero √∫nico ${singleNumber}:`, error);
      return null;
    }
  }
  
  // Para m√∫ltiples n√∫meros, continuar con el procesamiento normal
  // Limpiar y normalizar la entrada
  let cleanedInput = numbersText.trim();
  
  // Detectar si hay espacios despu√©s de las comas y normalizar
  if (cleanedInput.includes(', ')) {
    cleanedInput = cleanedInput.replace(/, /g, ',');
  }
  
  // Reemplazar m√∫ltiples espacios con comas
  cleanedInput = cleanedInput.replace(/\s+/g, ',');
  
  // Procesar la entrada para extraer los n√∫meros
  const numbersArray = cleanedInput
    .split(',')
    .map(n => n.trim())
    .filter(n => n.length > 0) // Eliminar elementos vac√≠os
    .map(n => {
      const parsed = parseInt(n);
      return parsed;
    })
    .filter(n => !isNaN(n) && n >= 0 && n <= 36); // Solo n√∫meros v√°lidos de ruleta (0-36)
  
  if (numbersArray.length === 0) {
    console.error('No se encontraron n√∫meros v√°lidos en la entrada');
    return null;
  }
  
  console.log(`N√∫meros extra√≠dos: ${numbersArray.join(', ')}`);
  
  // MEJORADO: Verificar duplicados consecutivos para m√∫ltiples n√∫meros
  const problematicNumbers = [];
  for (const num of numbersArray) {
    const duplicateCheck = checkConsecutiveDuplicate(num, recentNumberValues);
    if (duplicateCheck.isDuplicate) {
      problematicNumbers.push({ number: num, reason: duplicateCheck.message });
    }
  }
  
  if (problematicNumbers.length > 0) {
    const problemList = problematicNumbers.map(p => `${p.number} (${p.reason})`).join(', ');
    console.error(`N√∫meros con posibles duplicados: ${problemList}`);
    return {
      error: true,
      message: `Se detectaron posibles duplicados: ${problemList}. ¬øDesea continuar de todos modos?`,
      isDuplicate: true,
      duplicateNumbers: problematicNumbers.map(p => p.number),
      allowOverride: true
    };
  }
  
  // IMPORTANTE: En la entrada, el n√∫mero de la izquierda es el √∫ltimo jugado
  // Ejemplo: "19,20,12,11" - El 19 es el √∫ltimo n√∫mero jugado, debe ser procesado √öLTIMO para que aparezca como m√°s reciente
  // Invertimos el orden para procesarlos correctamente (el m√°s reciente se inserta al final)
  const processOrder = [...numbersArray].reverse(); // Invertir para procesar el m√°s reciente al final
  
  // Insertar n√∫meros en bloques m√°s peque√±os para evitar sobrecarga
  const validResults = [];
  const batchSize = 3; // Reducir el tama√±o del lote para evitar sobrecarga
  
  for (let i = 0; i < processOrder.length; i += batchSize) {
    const batch = processOrder.slice(i, i + batchSize);
    
    try {
      // Insertar cada n√∫mero individualmente manteniendo el orden temporal correcto
      const promises = batch.map(async (number, index) => {
        console.log(`Insertando n√∫mero ${number} del lote ${Math.floor(i/batchSize) + 1}`);
        
        // Calcular timestamp: los n√∫meros m√°s antiguos tienen timestamps m√°s antiguos
        const baseTime = new Date();
        const totalPosition = i + index;
        // Restamos segundos para que los n√∫meros anteriores en la secuencia tengan timestamps m√°s antiguos
        const adjustedTime = new Date(baseTime.getTime() - (processOrder.length - totalPosition - 1) * 1000);
        
        // A√±adir un retraso para evitar sobrecarga del servidor
        await new Promise(resolve => setTimeout(resolve, index * 100));
        return insertRouletteNumber(number, adjustedTime.toISOString());
      });
      
      const results = await Promise.all(promises);
      const batchResults = results.filter(r => r !== null);
      validResults.push(...batchResults);
      
      console.log(`Lote ${Math.floor(i/batchSize) + 1} procesado: ${batchResults.length} n√∫meros insertados`);
      
      // Esperar un momento entre lotes (reducido)
      if (i + batchSize < processOrder.length) {
        await new Promise(resolve => setTimeout(resolve, 300));
      }
    } catch (error) {
      console.error(`Error procesando lote ${Math.floor(i/batchSize) + 1}:`, error);
    }
  }
  
  // El √∫ltimo n√∫mero jugado es el primero en la lista original (izquierda)
  const lastPlayed = numbersArray[0];
  
  // Invalidar la cach√© forzosamente
  cachedNumbers = [];
  lastFetchTimestamp = 0;
  
  console.log(`Procesamiento completado: ${validResults.length}/${processOrder.length} n√∫meros procesados`);
  
  // Retornar la informaci√≥n de los n√∫meros procesados
  return {
    processedCount: validResults.length,
    totalInput: processOrder.length,
    numbers: validResults.map(r => r.number_value || r.number), // Asegurarse de obtener el n√∫mero correcto
    lastPlayed: lastPlayed, // El primer n√∫mero en la entrada (m√°s a la izquierda)
    individualEntries: validResults,
  };
};

// Obtener estad√≠sticas de los n√∫meros
export const getRouletteStats = async () => {
  const supabase = useSupabase();
  
  // Obtener todos los n√∫meros para calcular estad√≠sticas
  const { data, error } = await supabase
    .from('roulette_numbers_individual')
    .select('id, history_entry_id, number_value, color, created_at')
    .order('created_at', { ascending: false })
    .limit(500);
  
  if (error) {
    console.error('Error fetching data for stats:', error);
    return null;
  }
  
  // Transformar datos para mantener compatibilidad
  const transformedData = data.map(item => ({
    id: item.id,
    number: item.number_value,
    color: item.color,
    created_at: item.created_at,
    timestamp: item.created_at
  }));
  
  // Calcular estad√≠sticas
  const numberCounts = new Map<number, number>();
  let redCount = 0;
  let blackCount = 0;
  let oddCount = 0;
  let evenCount = 0;
  const columns = { c1: 0, c2: 0, c3: 0 };
  const dozens = { d1: 0, d2: 0, d3: 0 };
  
  // Los √∫ltimos n√∫meros - IMPORTANTE: mantener el orden con el m√°s reciente primero
  // Esto asegura que el √∫ltimo jugado aparezca a la izquierda en la visualizaci√≥n
  const lastNumbers = transformedData.slice(0, 20).map(item => item.number);
  
  // Analizar terminales (√∫ltimo d√≠gito)
  const terminals = Array(10).fill(0);
  
  transformedData.forEach(item => {
    const num = item.number;
    
    // Conteo de n√∫meros
    numberCounts.set(num, (numberCounts.get(num) || 0) + 1);
    
    // Rojo vs Negro
    if (item.color === 'red') redCount++;
    else if (item.color === 'black') blackCount++;
    
    // Par vs Impar
    if (num !== 0) {
      if (num % 2 === 0) evenCount++;
      else oddCount++;
    }
    
    // Columnas
    if (num !== 0) {
      if (num % 3 === 1) columns.c1++;
      else if (num % 3 === 2) columns.c2++;
      else columns.c3++;
    }
    
    // Docenas
    if (num >= 1 && num <= 12) dozens.d1++;
    else if (num >= 13 && num <= 24) dozens.d2++;
    else if (num >= 25 && num <= 36) dozens.d3++;
    
    // Terminal (√∫ltimo d√≠gito)
    const terminal = num % 10;
    terminals[terminal]++;
  });
  
  // Obtener los n√∫meros m√°s y menos frecuentes
  const sortedNumbers = Array.from(numberCounts.entries())
    .sort((a, b) => b[1] - a[1]);
  
  const hotNumbers = sortedNumbers.slice(0, 5).map(entry => entry[0]);
  const coldNumbers = sortedNumbers.slice(-5).map(entry => entry[0]);
  
  // Encontrar terminales m√°s frecuentes
  const terminalsSorted = terminals.map((count, digit) => ({ digit, count }))
                                  .sort((a, b) => b.count - a.count);
  const hotTerminals = terminalsSorted.slice(0, 3).map(t => t.digit);
  
  return {
    hotNumbers,
    coldNumbers,
    redVsBlack: { red: redCount, black: blackCount },
    oddVsEven: { odd: oddCount, even: evenCount },
    columns,
    dozens,
    lastNumbers,
    terminals: {
      counts: terminals,
      hot: hotTerminals
    }
  };
};

// Nueva funci√≥n para obtener secuencias de n√∫meros desde la tabla individual
export const getRouletteNumberSequences = async (limit = 100) => {
  const supabase = useSupabase();
  
  // Obtener los √∫ltimos n√∫meros
  const { data, error } = await supabase
    .from('roulette_numbers_individual')
    .select('id, history_entry_id, number_value, color, created_at')
    .order('created_at', { ascending: false })
    .limit(limit);
  
  if (error) {
    console.error('Error fetching roulette sequences:', error);
    return null;
  }
  
  // Transformar datos para mantener compatibilidad
  const transformedData = data.map(item => ({
    id: item.id,
    number: item.number_value,
    color: item.color,
    created_at: item.created_at,
    timestamp: item.created_at
  }));
  
  // Usamos dos conjuntos de datos:
  // 1. Orden original (m√°s reciente primero) para mostrar en la interfaz
  // 2. Orden cronol√≥gico para an√°lisis de secuencias
  const originalOrder = [...transformedData]; // El m√°s reciente primero (para mostrar)
  const chronologicalOrder = [...transformedData].reverse(); // De m√°s antiguo a m√°s reciente (para an√°lisis)
  
  // Definir tipo para los ciclos
  interface RouletteCycle {
    numbers: number[];
    sum: number;
    colors: string[];
  }
  
  // Analizar las secuencias
  const sequences = {
    // Para mostrar en la interfaz (m√°s reciente primero - izquierda)
    recentNumberSequence: originalOrder.slice(0, 10).map(item => item.number),
    
    // Para an√°lisis (orden cronol√≥gico)
    numberSequences: chronologicalOrder.map(item => item.number),
    colorSequences: chronologicalOrder.map(item => item.color),
    paritySequences: chronologicalOrder.map(item => item.number !== 0 ? (item.number % 2 === 0 ? 'even' : 'odd') : 'zero'),
    dozenSequences: chronologicalOrder.map(item => {
      if (item.number === 0) return 'zero';
      if (item.number <= 12) return 'd1';
      if (item.number <= 24) return 'd2';
      return 'd3';
    }),
    columnSequences: chronologicalOrder.map(item => {
      if (item.number === 0) return 'zero';
      if (item.number % 3 === 1) return 'c1';
      if (item.number % 3 === 2) return 'c2';
      return 'c3';
    }),
    // Agrupar por "ciclos" (cada 5 n√∫meros)
    cycles: [] as RouletteCycle[]
  };
  
  // Crear ciclos de 5 n√∫meros
  for (let i = 0; i < sequences.numberSequences.length; i += 5) {
    if (i + 5 <= sequences.numberSequences.length) {
      sequences.cycles.push({
        numbers: sequences.numberSequences.slice(i, i + 5),
        sum: sequences.numberSequences.slice(i, i + 5).reduce((sum, num) => sum + num, 0),
        colors: sequences.colorSequences.slice(i, i + 5)
      });
    }
  }
  
  return sequences;
};

// ============================================================================
// FUNCIONES DE PURGA DE BASE DE DATOS
// ============================================================================

// Obtener estado actual de la base de datos
export const obtenerEstadoBaseDatos = async () => {
  try {
    const apiBaseUrl = process.server ? '' : window.location.origin.includes('localhost') ? 'http://localhost:5000' : window.location.origin;
    
    const response = await fetch(`${apiBaseUrl}/estado-db`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    if (!response.ok) {
      throw new Error(`Error en la respuesta: ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error al obtener estado de la base de datos:', error);
    return {
      success: false,
      error: error.message || 'Error desconocido'
    };
  }
};

// Ejecutar purga manual de la base de datos
export const ejecutarPurgaManual = async (mantenerHoras = 48, mantenerMinimo = 50) => {
  try {
    const apiBaseUrl = process.server ? '' : window.location.origin.includes('localhost') ? 'http://localhost:5000' : window.location.origin;
    
    const response = await fetch(`${apiBaseUrl}/purgar-db`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        mantener_horas: mantenerHoras,
        mantener_minimo: mantenerMinimo
      })
    });
    
    if (!response.ok) {
      throw new Error(`Error en la respuesta: ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error al ejecutar purga manual:', error);
    return {
      success: false,
      error: error.message || 'Error desconocido'
    };
  }
};

// Verificar si la base de datos necesita purga
export const verificarNecesidadPurga = async () => {
  try {
    const estado = await obtenerEstadoBaseDatos();
    
    if (!estado.success) {
      return {
        necesita: false,
        error: estado.error
      };
    }
    
    const { estado: estadoDb } = estado;
    
    return {
      necesita: estadoDb.necesita_purga,
      horasDesdeAntiguo: estadoDb.horas_desde_mas_antiguo,
      totalRegistros: estadoDb.total_registros,
      registrosRecientes: {
        ultimas24h: estadoDb.registros_ultimas_24h,
        ultimas48h: estadoDb.registros_ultimas_48h
      },
      fechaAntigua: estadoDb.registro_mas_antiguo,
      fechaReciente: estadoDb.registro_mas_reciente
    };
  } catch (error) {
    console.error('Error al verificar necesidad de purga:', error);
    return {
      necesita: false,
      error: error.message || 'Error desconocido'
    };
  }
};

// Funci√≥n para mostrar informaci√≥n legible sobre el estado de la DB
export const formatearEstadoDb = (estadoRaw: any) => {
  if (!estadoRaw || !estadoRaw.success) {
    return {
      mensaje: 'Error al obtener estado de la base de datos',
      detalles: estadoRaw?.error || 'Error desconocido'
    };
  }
  
  const estado = estadoRaw.estado;
  
  // Formatear fechas
  const formatearFecha = (isoString: string) => {
    try {
      const fecha = new Date(isoString);
      return fecha.toLocaleString('es-ES');
    } catch {
      return 'Fecha inv√°lida';
    }
  };
  
  // Determinar el estado general
  let estadoGeneral = '';
  let color = '';
  
  if (estado.necesita_purga) {
    estadoGeneral = '‚ö†Ô∏è Necesita purga';
    color = 'text-orange-600';
  } else if (estado.horas_desde_mas_antiguo > 36) {
    estadoGeneral = '‚è≥ Pr√≥xima purga pronto';
    color = 'text-yellow-600';
  } else {
    estadoGeneral = '‚úÖ Estado normal';
    color = 'text-green-600';
  }
  
  return {
    estadoGeneral,
    color,
    totalRegistros: {
      individual: estado.total_registros.individual,
      history: estado.total_registros.history,
      total: estado.total_registros.individual + estado.total_registros.history
    },
    antiguedad: {
      horas: Math.round(estado.horas_desde_mas_antiguo * 100) / 100,
      fechaMasAntigua: estado.registro_mas_antiguo ? formatearFecha(estado.registro_mas_antiguo) : 'N/A',
      fechaMasReciente: estado.registro_mas_reciente ? formatearFecha(estado.registro_mas_reciente) : 'N/A'
    },
    registrosRecientes: {
      ultimas24h: estado.registros_ultimas_24h,
      ultimas48h: estado.registros_ultimas_48h,
      porcentaje24h: estado.total_registros.individual > 0 ? 
        Math.round((estado.registros_ultimas_24h / estado.total_registros.individual) * 100) : 0,
      porcentaje48h: estado.total_registros.individual > 0 ? 
        Math.round((estado.registros_ultimas_48h / estado.total_registros.individual) * 100) : 0
    },
    necesitaPurga: estado.necesita_purga,
    mensaje: `Base de datos con ${estado.total_registros.individual + estado.total_registros.history} registros. El m√°s antiguo tiene ${Math.round(estado.horas_desde_mas_antiguo)} horas.`
  };
};

// Funci√≥n para insertar un n√∫mero forzosamente, ignorando validaciones de duplicados
export const forceInsertNumber = async (number: number) => {
  console.log(`üî• FORZANDO inserci√≥n del n√∫mero ${number} (ignorando validaciones)`);
  
  // Validar que el n√∫mero sea v√°lido en la ruleta (0-36)
  if (number < 0 || number > 36 || isNaN(number)) {
    console.error(`N√∫mero inv√°lido: ${number}. Debe estar entre 0 y 36.`);
    return null;
  }
  
  try {
    // Insertar directamente sin verificar duplicados
    const result = await insertRouletteNumber(number);
    
    if (!result) {
      console.error(`No se pudo forzar la inserci√≥n del n√∫mero ${number}`);
      return null;
    }
    
    // Invalidar la cach√© forzosamente
    cachedNumbers = [];
    lastFetchTimestamp = 0;
    
    console.log(`‚úÖ N√∫mero ${number} FORZADO correctamente`);
    
    return {
      processedCount: 1,
      totalInput: 1,
      numbers: [number],
      lastPlayed: number,
      individualEntries: [result],
      forced: true // Marcar como inserci√≥n forzada
    };
  } catch (error) {
    console.error(`Error al forzar inserci√≥n del n√∫mero ${number}:`, error);
    return null;
  }
};

// Funci√≥n para procesar m√∫ltiples n√∫meros forzosamente con orden cronol√≥gico correcto
export const forceInsertMultipleNumbers = async (numbersText: string) => {
  console.log(`üî• FORZANDO inserci√≥n de m√∫ltiples n√∫meros: ${numbersText}`);
  
  // Limpiar y procesar la entrada
  const numbersArray = numbersText
    .split(',')
    .map(n => n.trim())
    .filter(n => n.length > 0)
    .map(n => parseInt(n))
    .filter(n => !isNaN(n) && n >= 0 && n <= 36);
  
  if (numbersArray.length === 0) {
    console.error('No se encontraron n√∫meros v√°lidos para forzar');
    return null;
  }
  
  console.log(`üìä N√∫meros extra√≠dos: [${numbersArray.join(', ')}]`);
  console.log(`‚è∞ Orden temporal: ${numbersArray[numbersArray.length - 1]} (m√°s viejo) ‚Üí ${numbersArray[0]} (m√°s reciente)`);
  
  // IMPORTANTE: Procesar de derecha a izquierda (m√°s viejo al m√°s reciente)
  const processOrder = [...numbersArray].reverse();
  console.log(`üîÑ Orden de forzado: [${processOrder.join(', ')}] (viejo ‚Üí reciente)`);
  
  try {
    // M√©todo 1: Intentar a trav√©s del backend
    try {
      const backendUrl = 'http://localhost:5000/reconocer-voz';
      const response = await fetch(backendUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          text: numbersText,
          force_insert: true
        })
      });
      
      if (response.ok) {
        const data = await response.json();
        console.log('‚úÖ Inserci√≥n forzada exitosa via backend:', data);
        
        // Invalidar cach√©
        cachedNumbers = [];
        lastFetchTimestamp = 0;
        
        return {
          processedCount: numbersArray.length,
          totalInput: numbersArray.length,
          numbers: numbersArray,
          lastPlayed: numbersArray[0], // El primero es el m√°s reciente
          forced: true,
          method: 'backend'
        };
      }
    } catch (backendError) {
      console.warn('Backend no disponible, intentando inserci√≥n directa:', backendError);
    }
    
    // M√©todo 2: Inserci√≥n directa usando Supabase con orden cronol√≥gico correcto
    console.log('Usando inserci√≥n directa con Supabase con orden cronol√≥gico...');
    
    const validResults = [];
    
    for (let i = 0; i < processOrder.length; i++) {
      const number = processOrder[i];
      const originalPosition = numbersArray.length - i;
      
      console.log(`üî¢ Forzando n√∫mero ${number} (pos. original: ${originalPosition})`);
      
      try {
        // Calcular timestamp para mantener orden cronol√≥gico correcto
        const baseTime = new Date();
        const adjustedTime = new Date(baseTime.getTime() - (processOrder.length - i - 1) * 1000);
        
        const result = await insertRouletteNumber(number, adjustedTime.toISOString());
        
        if (result) {
          validResults.push(result);
          console.log(`‚úÖ N√∫mero ${number} forzado directamente (pos. ${originalPosition})`);
        } else {
          console.error(`‚ùå Error al forzar n√∫mero ${number}`);
        }
        
        // Peque√±a pausa entre inserciones para evitar conflictos
        if (i < processOrder.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 300));
        }
      } catch (error) {
        console.error(`Error al insertar n√∫mero ${number}:`, error);
      }
    }
    
    // Invalidar cach√©
    cachedNumbers = [];
    lastFetchTimestamp = 0;
    
    if (validResults.length > 0) {
      console.log(`‚úÖ Inserci√≥n forzada completada: ${validResults.length}/${numbersArray.length} n√∫meros`);
      
      return {
        processedCount: validResults.length,
        totalInput: numbersArray.length,
        numbers: validResults.map(r => r.number_value || r.number),
        lastPlayed: numbersArray[0], // El primero en la entrada original (m√°s reciente)
        individualEntries: validResults,
        forced: true,
        method: 'direct_supabase_chronological'
      };
    } else {
      throw new Error('No se pudo insertar ning√∫n n√∫mero');
    }
    
  } catch (error) {
    console.error('Error en inserci√≥n forzada m√∫ltiple:', error);
    throw error;
  }
}; 